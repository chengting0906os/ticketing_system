# =============================================================================
# Standalone Consumers Configuration
# =============================================================================
# This file defines standalone Kafka consumers that run independently from the API service
#
# Architecture Flow:
#   Ticketing (HTTP) → Booking Service → Reservation Service → PostgreSQL
#
# Services:
# - booking-service: Receives from Ticketing, saves metadata to Kvrocks, publishes to Reservation
# - reservation-service: Reserves seats in Kvrocks, writes to PostgreSQL, SSE broadcast
#
# Usage:
#   docker-compose -f docker-compose.yml -f docker-compose.consumers.yml up -d
#
# Benefits:
# - Independent scaling (scale consumers without affecting API)
# - Clean separation of concerns
# - No transactional ID conflicts across worker processes
# - Easier to debug and monitor
# =============================================================================

services:
  # =============================================================================
  # Seat Reservation Service (Standalone Consumer)
  # =============================================================================
  # This service handles:
  # - Seat reservation in Kvrocks (atomic operations)
  # - PostgreSQL writes (booking + tickets)
  # - SSE broadcast for real-time UI updates
  # =============================================================================
  reservation-service:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
      args:
        SERVICE_TYPE: consumer
    image: reservation-service:latest
    command:
      - /bin/sh
      - -c
      - |
        export KAFKA_CONSUMER_INSTANCE_ID="reservation-service-consumer-$$(hostname)"
        export KAFKA_PRODUCER_INSTANCE_ID="reservation-service-producer-$$(hostname)"
        /app/.venv/bin/python src/service/reservation/driving_adapter/start_reservation_consumer.py
    environment:
      # Python
      PYTHONPATH: /app

      # Application (can override .env values)
      EVENT_ID: "${EVENT_ID:-1}"
      DEBUG: "${DEBUG:-False}"
      LOG_LEVEL: "${LOG_LEVEL:-INFO}"
      TZ: "Asia/Taipei"

      # Database (for PostgreSQL writes)
      POSTGRES_SERVER: postgres
      POSTGRES_PORT: "5432"
      POSTGRES_DB: "${POSTGRES_DB:-ticketing_system_db}"
      POSTGRES_USER: "${POSTGRES_USER:-postgres}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD:-postgres}"

      # KVRocks Cluster (all services run in Docker network)
      KVROCKS_CLUSTER_MODE: "true"
      KVROCKS_CLUSTER_NODES: "kvrocks-1:6666,kvrocks-2:6666,kvrocks-3:6666,kvrocks-4:6666"
      KVROCKS_HOST: kvrocks-1
      KVROCKS_PORT: "6666"

      # Kafka
      KAFKA_BOOTSTRAP_SERVERS: kafka1:29092,kafka2:29092,kafka3:29092
      # Note: KAFKA_*_INSTANCE_ID is set dynamically in the command using $(hostname)

      # OpenTelemetry
      OTEL_SERVICE_NAME: reservation-service
      OTEL_EXPORTER_OTLP_ENDPOINT: http://jaeger:4317
      OTEL_TRACES_EXPORTER: otlp
      OTEL_METRICS_EXPORTER: none
      OTEL_LOGS_EXPORTER: none
      OTEL_PYTHON_LOGGING_AUTO_INSTRUMENTATION_ENABLED: "true"
    env_file:
      - .env
    volumes:
      - ./src:/app/src:ro

    depends_on:
      postgres:
        condition: service_healthy
      kafka1:
        condition: service_started
      kafka2:
        condition: service_started
      kafka3:
        condition: service_started
      kvrocks-init:
        condition: service_completed_successfully
      jaeger:
        condition: service_healthy
    networks:
      - ticketing-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.25' # 0.5 core per instance (2 cores total for 4 instances)
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    logging:
      driver: "local"
      options:
        max-size: "100m"
        max-file: "100"
        mode: "non-blocking"
        max-buffer-size: "4m"
    labels:
      - "service.type=consumer"
      - "service.name=reservation-service"

  # =============================================================================
  # Booking Service (Standalone Consumer)
  # =============================================================================
  # This service handles booking metadata management:
  # - Receives BookingCreated event from Ticketing Service
  # - Saves booking metadata to Kvrocks
  # - Publishes to Reservation Service for seat reservation
  # =============================================================================
  booking-service:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
      args:
        SERVICE_TYPE: consumer
    image: booking-service:latest
    command:
      - /bin/sh
      - -c
      - |
        export KAFKA_CONSUMER_INSTANCE_ID="booking-service-consumer-$$(hostname)"
        export KAFKA_PRODUCER_INSTANCE_ID="booking-service-producer-$$(hostname)"
        /app/.venv/bin/python src/service/booking/driving_adapter/mq_consumer/start_booking_consumer.py
    environment:
      # Python
      PYTHONPATH: /app

      # Application
      EVENT_ID: "${EVENT_ID:-1}"
      DEBUG: "${DEBUG:-False}"
      LOG_LEVEL: "${LOG_LEVEL:-INFO}"
      TZ: "Asia/Taipei"

      # KVRocks Cluster (all services run in Docker network)
      KVROCKS_CLUSTER_MODE: "true"
      KVROCKS_CLUSTER_NODES: "kvrocks-1:6666,kvrocks-2:6666,kvrocks-3:6666,kvrocks-4:6666"
      KVROCKS_HOST: kvrocks-1
      KVROCKS_PORT: "6666"

      # Kafka
      KAFKA_BOOTSTRAP_SERVERS: kafka1:29092,kafka2:29092,kafka3:29092

      # OpenTelemetry
      OTEL_SERVICE_NAME: booking-service
      OTEL_EXPORTER_OTLP_ENDPOINT: http://jaeger:4317
      OTEL_TRACES_EXPORTER: otlp
      OTEL_METRICS_EXPORTER: none
      OTEL_LOGS_EXPORTER: none
      OTEL_PYTHON_LOGGING_AUTO_INSTRUMENTATION_ENABLED: "true"
    env_file:
      - .env
    volumes:
      - ./src:/app/src:ro

    depends_on:
      kafka1:
        condition: service_started
      kafka2:
        condition: service_started
      kafka3:
        condition: service_started
      kvrocks-init:
        condition: service_completed_successfully
      jaeger:
        condition: service_healthy
    networks:
      - ticketing-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.25' # 0.5 core per instance (1 core total for 2 instances)
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    logging:
      driver: "local"
      options:
        max-size: "100m"
        max-file: "100"
        mode: "non-blocking"
        max-buffer-size: "4m"
    labels:
      - "service.type=consumer"
      - "service.name=booking-service"

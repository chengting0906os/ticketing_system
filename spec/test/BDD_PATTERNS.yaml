# Ticketing System - BDD Test Pattern Configuration
# This document defines the standard patterns for pytest-bdd tests in this project.
#
# Architecture Overview:
#   test/
#   ├── conftest.py                    # Global fixtures (TestClient, execute_sql_statement)
#   ├── loader.py                      # Imports all BDD step definitions
#   ├── constants.py                   # Test constants (emails, passwords, seating configs)
#   ├── bdd_conftest/                  # Shared BDD step definitions
#   │   ├── shared_step_utils.py       # Utility functions for steps
#   │   ├── given_step_conftest.py     # Common Given steps
#   │   ├── when_step_conftest.py      # Common When steps (HTTP actions)
#   │   └── then_step_conftest.py      # Common Then steps (assertions)
#   └── service/ticketing/
#       ├── booking/
#       │   ├── conftest.py            # Booking-specific steps
#       │   └── *.feature              # Booking scenarios
#       ├── event_ticketing/
#       │   ├── conftest.py            # Event-specific steps
#       │   └── *.feature              # Event scenarios
#       └── reservation/
#           ├── conftest.py            # Reservation-specific steps
#           └── *.feature              # Reservation scenarios

# =============================================================================
# GIVEN PATTERNS - Setup test preconditions
# =============================================================================

given_patterns:
  # --- Authentication ---
  authentication:
    seller_simple:
      pattern: 'I am logged in as a seller'
      location: bdd_conftest/given_step_conftest.py
      description: Login as default seller (creates if not exists)
      example: |
        Given I am logged in as a seller

    buyer_simple:
      pattern: 'I am logged in as a buyer'
      location: bdd_conftest/given_step_conftest.py
      description: Login as default buyer (creates if not exists)
      example: |
        Given I am logged in as a buyer

    seller_with_table:
      pattern: 'I am logged in as a seller with'
      location: bdd_conftest/given_step_conftest.py
      description: Create and login as seller with specified credentials
      example: |
        Given I am logged in as a seller with
          | email           | password | name        |
          | seller@test.com | P@ssw0rd | Test Seller |

    buyer_with_table:
      pattern: 'I am logged in as a buyer with'
      location: bdd_conftest/given_step_conftest.py
      description: Create and login as buyer with specified credentials
      example: |
        Given I am logged in as a buyer with
          | email          | password | name       |
          | buyer@test.com | P@ssw0rd | Test Buyer |

    role_parameterized:
      pattern: 'I am logged in as "{role}"'
      location: bdd_conftest/given_step_conftest.py
      description: Login as specified role with default credentials
      example: |
        Given I am logged in as "seller"
        Given I am logged in as "buyer"

    role_with_table:
      pattern: 'I am logged in as "{role}" with'
      location: bdd_conftest/given_step_conftest.py
      description: Create and login as specified role with table credentials
      example: |
        Given I am logged in as "seller" with
          | email           | password | name        |
          | seller@test.com | P@ssw0rd | Test Seller |

  # --- User Creation (without login) ---
  user_creation:
    seller_exists:
      pattern: 'a seller exists'
      location: bdd_conftest/given_step_conftest.py
      description: Create a seller with default credentials (no login)
      example: |
        Given a seller exists

    buyer_exists:
      pattern: 'a buyer exists'
      location: bdd_conftest/given_step_conftest.py
      description: Create a buyer with default credentials (no login)
      example: |
        Given a buyer exists

  # --- Event Creation ---
  event_creation:
    event_with_table:
      pattern: 'an event exists with:'
      location: bdd_conftest/given_step_conftest.py
      description: Create event via API with specified attributes
      example: |
        Given an event exists with:
          | name         | description | is_active | status    | venue_name   | seating_config |
          | Test Concert | Test event  | true      | available | Taipei Arena | {...}          |

# =============================================================================
# WHEN PATTERNS - Execute HTTP actions
# =============================================================================

when_patterns:
  # --- HTTP Methods ---
  http_actions:
    post_with_data:
      pattern: 'I call POST "{endpoint}" with'
      location: bdd_conftest/when_step_conftest.py
      description: POST request with datatable body, supports variable substitution
      example: |
        When I call POST "/api/user/register" with
          | email            | password | name     | role  |
          | test@example.com | P@ssw0rd | TestUser | buyer |

        When I call POST "/api/booking" with
          | event_id   | section | quantity |
          | {event_id} | A       | 2        |

    post_no_data:
      pattern: 'I call POST "{endpoint}"'
      location: bdd_conftest/when_step_conftest.py
      description: POST request without body (e.g., refresh actions)
      example: |
        When I call POST "/api/auth/refresh"

    get:
      pattern: 'I call GET "{endpoint}"'
      location: bdd_conftest/when_step_conftest.py
      description: GET request, supports variable substitution in endpoint
      example: |
        When I call GET "/api/event/1"
        When I call GET "/api/event/{event_id}"

    put_with_data:
      pattern: 'I call PUT "{endpoint}" with'
      location: bdd_conftest/when_step_conftest.py
      description: PUT request with datatable body
      example: |
        When I call PUT "/api/event/1" with
          | name     | description |
          | New Name | New Desc    |

    patch_with_data:
      pattern: 'I call PATCH "{endpoint}" with'
      location: bdd_conftest/when_step_conftest.py
      description: PATCH request with datatable body
      example: |
        When I call PATCH "/api/event/1" with
          | is_active |
          | false     |

    patch_no_data:
      pattern: 'I call PATCH "{endpoint}"'
      location: bdd_conftest/when_step_conftest.py
      description: PATCH request without body (e.g., cancel actions)
      example: |
        When I call PATCH "/api/booking/{booking.id}/cancel"

    delete:
      pattern: 'I call DELETE "{endpoint}"'
      location: bdd_conftest/when_step_conftest.py
      description: DELETE request
      example: |
        When I call DELETE "/api/event/1"
        When I call DELETE "/api/event/{event_id}"

# =============================================================================
# THEN PATTERNS - Verify results
# =============================================================================

then_patterns:
  # --- Status Code Validation ---
  status_validation:
    pattern: 'the response status code should be {status_code}'
    location: bdd_conftest/then_step_conftest.py
    example: |
      Then the response status code should be 200
      Then the response status code should be 201
      Then the response status code should be 400
      Then the response status code should be 404

  # --- Error Validation ---
  error_validation:
    pattern: 'the error message should contain "{text}"'
    location: bdd_conftest/then_step_conftest.py
    description: Case-insensitive check for error message
    example: |
      Then the error message should contain "not found"
      Then the error message should contain "Invalid"

  # --- Response Body Validation ---
  response_body:
    contains_field:
      pattern: 'the response should contain "{field}"'
      location: bdd_conftest/then_step_conftest.py
      example: |
        Then the response should contain "id"
        Then the response should contain "status"

    field_equals:
      pattern: 'the response field "{field}" should be "{value}"'
      location: bdd_conftest/then_step_conftest.py
      description: Verify single field value with type conversion
      example: |
        Then the response field "status" should be "pending"
        Then the response field "role" should be "buyer"

    empty:
      pattern: 'the response should be empty'
      location: bdd_conftest/then_step_conftest.py
      example: |
        Then the response should be empty

    list_count:
      pattern: 'the response should have {count} items'
      location: bdd_conftest/then_step_conftest.py
      example: |
        Then the response should have 5 items
        Then the response should have 0 items

    data_include:
      pattern: 'the response data should include:'
      location: bdd_conftest/then_step_conftest.py
      description: Verify multiple field-value pairs with special value support
      example: |
        Then the response data should include:
          | status     | id       |
          | processing | not_null |

        And the response data should include:
          | name         | venue_name   | is_active |
          | Rock Concert | Taipei Arena | true      |

  # --- Database Verification ---
  database_validation:
    row_count:
      pattern: 'the database "{table}" should have {count} rows where "{column}" is "{value}"'
      location: bdd_conftest/then_step_conftest.py
      example: |
        Then the database "ticket" should have 10 rows where "status" is "available"
        Then the database "booking" should have 0 rows where "status" is "cancelled"

    row_match:
      pattern: 'the database row should match:'
      location: bdd_conftest/then_step_conftest.py
      description: Verify database row exists with specified conditions
      example: |
        Then the database row should match:
          | table  | status    | buyer_id |
          | ticket | available | not_null |

# =============================================================================
# DATATABLE FORMATS
# =============================================================================

datatable_formats:
  # Single row key-value (most common)
  single_row:
    format: |
      | field1 | field2 | field3 |
      | value1 | value2 | value3 |
    used_for:
      - Entity creation (POST body)
      - Login credentials
      - Update data (PUT/PATCH body)
      - Response validation
    example: |
      | email           | password | name        |
      | seller@test.com | P@ssw0rd | Test Seller |

  # Multi-row for batch operations
  multi_row:
    format: |
      | field1 | field2 |
      | val1a  | val1b  |
      | val2a  | val2b  |
    used_for:
      - Batch user creation
      - Multiple bookings setup
      - Ticket lists
    example: |
      | id | buyer_id | event_id | status  |
      | 1  | 6        | 1        | pending |
      | 2  | 7        | 1        | paid    |

  # Single value table
  single_value:
    format: |
      | value |
    used_for:
      - Simple count checks
      - Single status verification
    example: |
      | 10 |

# =============================================================================
# SPECIAL VALUES & PLACEHOLDERS
# =============================================================================

special_values:
  # Endpoint variable substitution
  endpoint_variables:
    pattern: '{key}' or '{object.field}'
    description: Resolved from context dictionary
    examples:
      '{event_id}': 'context["event_id"]'
      '{booking.id}': 'context["booking"]["id"]'
      '{user_id}': 'context["user_id"]'
    example: |
      /api/event/{event_id}         -> /api/event/123
      /api/booking/{booking.id}     -> /api/booking/abc-def-123

  # Table value substitution (same as endpoint)
  table_variables:
    description: Variables in table values are also resolved
    example: |
      | event_id   | section |
      | {event_id} | A       |

  # Validation placeholders
  validation_placeholders:
    not_null: Asserts value is not None
    null: Asserts value is None
    '{any_int}': Asserts value is any integer
    'PREFIX_*': Asserts string starts with PREFIX_ (wildcard)
    true: Boolean True (case-insensitive)
    false: Boolean False (case-insensitive)

  # Type conversion in table values
  type_conversion:
    integers: '123' -> 123 (only if <= 10 digits)
    booleans: 'true'/'false' -> True/False
    null: 'none'/'null' -> None
    json_array: '["a","b"]' -> ["a", "b"]
    json_object: '{"key":"value"}' -> {"key": "value"}
    long_numbers: '1234567890123' -> kept as string (card numbers, etc.)

# =============================================================================
# CONTEXT DICTIONARY
# =============================================================================

context_structure:
  description: Shared state between BDD steps via context fixture
  keys:
    # Response data
    response: Current HTTP response object
    response_data: Parsed JSON response body
    request_data: Data sent in the request

    # User data
    current_user: Currently logged-in user
    current_user_id: ID of current user
    seller: Seller user data
    seller_id: Seller user ID
    buyer: Buyer user data
    buyer_id: Buyer user ID

    # Entity data
    event: Current event data
    event_id: Current event ID
    booking: Current booking data
    booking.id: Current booking ID (UUID string)
    updated_booking: Updated booking after action
    updated_event: Updated event after action

    # Collections
    users: Dict of created users by ID
    events: Dict of created events by ID
    bookings: Dict of created bookings by ID

  example: |
    context = {
        'response': <Response>,
        'response_data': {'id': 1, 'status': 'available'},
        'current_user': {'id': 1, 'email': 'seller@test.com'},
        'seller_id': 1,
        'event': {'id': 1, 'name': 'Concert'},
        'event_id': 1,
        'booking': {'id': 'abc-123', 'status': 'pending'},
    }

# =============================================================================
# TEST CLIENT & FIXTURES
# =============================================================================

test_client:
  type: FastAPI TestClient
  location: test/conftest.py
  description: Synchronous test client with session cookie support
  features:
    - Session-based authentication
    - Cookie management (auto-cleared between tests)
    - raise_server_exceptions=False for proper error testing
  scope: session

fixtures:
  global:
    location: test/conftest.py
    items:
      client: FastAPI TestClient (session-scoped)
      context: Dict for step communication (function-scoped)
      execute_sql_statement: Direct SQL execution helper
      seller_user: Pre-created seller user
      buyer_user: Pre-created buyer user
      clean_database: Auto-cleanup between tests
      clean_kvrocks: Auto-cleanup Kvrocks between tests

  module:
    location: test/service/ticketing/{module}/conftest.py
    description: Module-specific step definitions and fixtures

# =============================================================================
# CONVENTIONS & BEST PRACTICES
# =============================================================================

conventions:
  file_naming:
    feature_files: '{feature_name}_integration_test.feature'
    step_files: 'conftest.py (in same directory as .feature files)'

  step_organization:
    global_steps: test/bdd_conftest/*_step_conftest.py
    module_steps: test/service/ticketing/{module}/conftest.py
    rule: |
      1. Check if step exists in bdd_conftest/ first
      2. Only create module-specific steps when truly unique to that module
      3. Consider promoting to global if step is used in multiple modules

  markers:
    '@pytest.mark.integration': All BDD integration tests

  default_credentials:
    password: 'P@ssw0rd'
    seller_email: 'seller@test.com'
    buyer_email: 'buyer@test.com'

  context_naming:
    description: Use consistent keys for entities
    examples:
      - 'event' for current event (not 'created_event')
      - 'event_id' for event ID (not 'eventId')
      - 'booking.id' for nested access
      - '{role}_id' for user IDs (seller_id, buyer_id)

# =============================================================================
# ADDING NEW STEPS
# =============================================================================

adding_new_steps:
  checklist:
    - Check if step already exists in bdd_conftest/
    - Determine if step is reusable (global) or module-specific
    - Use parsers.parse() for parameterized steps
    - Store results in context dict appropriately
    - Add docstring with Example usage
    - Update this file if adding global steps

  global_step_template: |
    @given(parsers.parse('pattern with "{param}"'))
    def given_step_name(
        param: str,
        client: TestClient,
        context: dict[str, Any],
    ) -> None:
        """Step description.

        Example:
            Given pattern with "value"
        """
        # Implementation
        context['key'] = value

  module_step_template: |
    @then('the specific assertion')
    def then_specific_assertion(context: dict[str, Any]) -> None:
        """Module-specific validation."""
        response = context['response']
        # Validation logic

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

utility_functions:
  location: test/bdd_conftest/shared_step_utils.py
  functions:
    extract_table_data:
      description: Extract first row of table data as dict
      signature: 'extract_table_data(step: Step) -> dict[str, str]'

    extract_single_value:
      description: Extract single value from simple table
      signature: 'extract_single_value(step: Step) -> str'

    convert_table_values:
      description: Convert string values to appropriate types
      signature: 'convert_table_values(data: dict[str, str]) -> dict[str, Any]'

    resolve_endpoint_vars:
      description: Resolve {var} placeholders in endpoint from context
      signature: 'resolve_endpoint_vars(endpoint: str, context: dict) -> str'

    resolve_table_vars:
      description: Resolve {var} placeholders in table values from context
      signature: 'resolve_table_vars(data: dict, context: dict) -> dict'

    create_user_if_not_exists:
      description: Create user via API, returns None if exists
      signature: 'create_user_if_not_exists(client, email, password, name, role) -> dict | None'

    login_user:
      description: Login user and return response data
      signature: 'login_user(client, email, password) -> dict'

    store_user_in_context:
      description: Store user info in context with role
      signature: 'store_user_in_context(user, role, context, set_as_current=True)'

    assert_response_status:
      description: Assert response has expected status code
      signature: 'assert_response_status(response, expected_status, message=None)'

    parse_seating_config:
      description: Parse seating config JSON string
      signature: 'parse_seating_config(seating_config_str: str | None) -> dict'

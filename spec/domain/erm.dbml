// Event Ticketing - Entity Relationship Model
// Extracted from EVENT_TICKETING_SPEC.md and BOOKING_SPEC.md

// ============================================
// Enums
// ============================================

Enum EventStatus {
  DRAFT [note: 'Draft (just created, tickets not yet generated)']
  AVAILABLE [note: 'Available for purchase']
  SOLD_OUT [note: 'Sold out (all tickets sold)']
  COMPLETED [note: 'Completed (manually by seller)']
  // ENDED - Not implemented for now

  Note: '''
  State Transitions (Mixed Mode):
  - DRAFT -> AVAILABLE: Automatic after ticket generation
  - AVAILABLE -> SOLD_OUT: Automatic when all tickets are sold
  - AVAILABLE -> COMPLETED: Manual by seller
  '''
}

Enum TicketStatus {
  AVAILABLE [note: 'Available for purchase']
  RESERVED [note: 'Reserved (can return to AVAILABLE on timeout/cancel)']
  SOLD [note: 'Sold (final state)']

  Note: '''
  State Transitions:
  - AVAILABLE -> RESERVED: On reservation
  - RESERVED -> SOLD: On payment confirmation
  - RESERVED -> AVAILABLE: On timeout or cancellation
  '''
}

Enum BookingStatus {
  PROCESSING [note: 'Processing (initial state, waiting for seat reservation confirmation)']
  PENDING_PAYMENT [note: 'Pending payment (seats reserved successfully)']
  COMPLETED [note: 'Completed (payment successful)']
  CANCELLED [note: 'Cancelled']
  FAILED [note: 'Failed (seat reservation failed)']

  Note: '''
  State Transitions:
  - PROCESSING -> PENDING_PAYMENT: Automatic when seats reserved successfully
  - PROCESSING -> FAILED: Automatic when seat reservation fails
  - PROCESSING -> CANCELLED: Manual by buyer
  - PENDING_PAYMENT -> COMPLETED: On payment confirmation
  - PENDING_PAYMENT -> CANCELLED: Manual by buyer

  Terminal States: COMPLETED, CANCELLED, FAILED (cannot be changed)
  '''
}

// ============================================
// Entities
// ============================================

Table Event {
  id int [pk, note: 'Primary key, auto-generated']
  name string [not null, note: 'Event name, not empty']
  description string [not null, note: 'Event description, not empty']
  seller_id int [not null, ref: > User.id, note: 'Seller ID, FK to User']
  venue_name string [not null, note: 'Venue name, not empty']
  seating_config json [note: 'Seating configuration (JSON format: {rows, cols, sections[]})']
  stats jsonb [not null, default: `{"available": 0, "reserved": 0, "sold": 0, "total": 0}`, note: 'Event-level statistics (updated by trigger)']
  is_active bool [default: true, note: 'Whether the event is active/published']
  status EventStatus [note: 'Event status']

  Note: '''
  Event Entity - Manages event creation, query, and status management

  Business Rules:
  - Only Sellers can create events
  - Creating an event auto-generates all seat tickets based on seating_config

  State Transitions (see EventStatus enum):
  - DRAFT -> AVAILABLE: Automatic after ticket generation
  - AVAILABLE -> SOLD_OUT: Automatic when all tickets sold
  - AVAILABLE -> COMPLETED: Manual by seller

  Cross-Attribute Invariants:
  - Ticket count = rows x cols x sections x subsections (from seating_config)

  Compensation Transaction (on Kvrocks init failure):
  1. Delete Kvrocks seat data (if any)
  2. Delete Tickets from DB
  3. Delete Event from DB

  Relationships:
  - Event 1:N Ticket
  '''
}

Table Ticket {
  id int [pk, note: 'Primary key, auto-generated']
  event_id int [not null, ref: > Event.id, note: 'Event ID, FK to Event']
  section string [not null, note: 'Section name, e.g., "A"']
  subsection int [not null, note: 'Subsection number, e.g., 1']
  row_number int [not null, note: 'Row number, e.g., 1']
  seat_number int [not null, note: 'Seat number, e.g., 1']
  price int [not null, note: 'Ticket price, >= 0']
  status TicketStatus [note: 'Ticket status']
  buyer_id int [note: 'Buyer ID, Nullable, FK to User']
  reserved_at datetime [note: 'Reservation timestamp, Nullable']
  created_at datetime [not null, default: `now()`, note: 'Creation timestamp']
  updated_at datetime [not null, default: `now()`, note: 'Update timestamp']

  Note: '''
  Ticket Entity - Manages event seat tickets

  Business Rules:
  - Ticket price must be >= 0
  - Unique constraint: (event_id, section, subsection, row_number, seat_number)

  Relationships:
  - Ticket N:1 Event
  '''
}

Table User {
  id int [pk, note: 'Primary key, auto-generated']
  email string [not null, unique, note: 'User email, unique']
  hashed_password string [not null, note: 'Hashed password']
  name string [not null, note: 'User name']
  role string [not null, note: 'User role: seller/buyer']
  created_at datetime [not null, default: `now()`, note: 'Creation timestamp']
  is_active bool [not null, note: 'Whether the user is active']
  is_superuser bool [not null, note: 'Whether the user is superuser']
  is_verified bool [not null, note: 'Whether the user is verified']

  Note: '''
  User Entity - User accounts (seller/buyer)
  '''
}

Table Booking {
  id string [pk, note: 'Primary key, UUID7 format']
  buyer_id int [not null, ref: > User.id, note: 'Buyer ID, FK to User']
  event_id int [not null, ref: > Event.id, note: 'Event ID, FK to Event']
  total_price int [not null, note: 'Total price in cents, >= 0']
  section string [not null, note: 'Section name, e.g., "A"']
  subsection int [not null, note: 'Subsection number, e.g., 1']
  quantity int [not null, note: 'Number of tickets, 1-4']
  seat_selection_mode string [not null, note: 'Selection mode: "manual" or "best_available"']
  seat_positions string [note: 'Seat positions as JSON array, e.g., ["1-1", "1-2"]. Format: "row-seat"']
  status BookingStatus [note: 'Booking status']
  created_at string [note: 'Creation timestamp (UTC), auto']
  updated_at string [note: 'Update timestamp (UTC), auto']
  paid_at string [note: 'Payment timestamp (UTC), Nullable']

  Note: '''
  Booking Entity - Manages ticket booking creation, query, payment, and cancellation

  Business Rules:
  - Quantity limit: 1-4 tickets per booking
  - seat_selection_mode:
    - "manual": Must provide seat_positions, count must equal quantity
    - "best_available": seat_positions must be empty array, system selects seats
  - Fail Fast: Check seat availability before creating booking
  - Only buyer can cancel or pay their own booking
  - Only PROCESSING and PENDING_PAYMENT status can be cancelled
  - Only PENDING_PAYMENT status can be paid
  - COMPLETED, CANCELLED, FAILED are terminal states

  Cross-Attribute Invariants:
  - When seat_selection_mode = "manual": len(seat_positions) == quantity
  - When seat_selection_mode = "best_available": seat_positions == []

  Relationships:
  - Booking N:1 User (buyer)
  - Booking N:1 Event
  - Booking 1:N Ticket (through reserved tickets)
  '''
}

Table SubsectionStats {
  event_id int [pk, ref: > Event.id, note: 'Event ID, FK to Event']
  section string [pk, note: 'Section name, e.g., "A"']
  subsection int [pk, note: 'Subsection number, e.g., 1']
  price int [not null, note: 'Ticket price for this subsection']
  available int [not null, default: 0, note: 'Count of available seats']
  reserved int [not null, default: 0, note: 'Count of reserved seats']
  sold int [not null, default: 0, note: 'Count of sold seats']
  updated_at bigint [note: 'Last update timestamp (epoch)']

  Note: '''
  SubsectionStats Entity - Subsection-level statistics

  Updated by: ticket_status_change_trigger
  Primary Key: (event_id, section, subsection)
  '''
}

// ============================================
// Relationships
// ============================================

// Event & Ticket relationships
Ref: Ticket.event_id > Event.id [note: 'Event 1:N Ticket - One event has many tickets']
Ref: Event.seller_id > User.id [note: 'User 1:N Event - One seller can have many events']
Ref: Ticket.buyer_id > User.id [note: 'User 1:N Ticket - One buyer can purchase many tickets']

// Booking relationships
Ref: Booking.buyer_id > User.id [note: 'User 1:N Booking - One buyer can have many bookings']
Ref: Booking.event_id > Event.id [note: 'Event 1:N Booking - One event can have many bookings']

// SubsectionStats relationships
Ref: SubsectionStats.event_id > Event.id [note: 'Event 1:N SubsectionStats - One event has many subsection stats']

// ============================================
// Triggers
// ============================================

// ticket_status_change_trigger
// - Triggered on: INSERT, UPDATE (status) on ticket table
// - Updates: event.stats (JSONB) + subsection_stats table
// - Strategy: Differential (+/-) updates for performance
// - Source: src/platform/database/trigger/update_event_stats.sql
